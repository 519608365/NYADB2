/*
   tree_recovery.go 描述B+树的事务无关和错误处理

   B+树是事务无关的, 既B+树直接以超级事务(SUPER_XID)在执行.
   试想如果某个事务, 在B+树中插入了很多索引, 然后又被回滚了, 会怎么样?
   结果就是该事务的索引依然留在B+树种, 但是VM却”读不出来”, 和B+树没有Delete操作类似, 因此不会对其他事务造成影响, 这些废弃的索引是安全的.

   现在再来看看如果B+树在执行过程中, 发生了崩溃会怎么样?
   如果Ti在对u进行修改时, 发生了崩溃, 那么节点u的内部结构就被破坏了, 但是由于B+树是建立在DM上的, 在下一次数据库重启时, u就会被恢复成修改之前的状态.
   也就是说, 由于DM的保护, 对B+树节点的操作, 是原子性的!

   于是我们现在就不用考虑节点内部错误的情况了, 只需要考虑节点间错误的情况, 而这样的错误情况只有一种:
        某次对u的插入操作创建了新节点v, 此时s(u)=v, 但是v却并没有被插入到他的父节点中. 于是成了大致如下的状态:
           [parent]
               |
               v
              [u] -> [v]

   而正确的状态应该如下:
           [ parent ]
            |      |
            v      v
           [u] -> [v]
   和正确状态相比, 错误状态下, 少了一支从父亲节点到v的指针.
   但是这样是没问题的! 因为在插入和查询操作中, 如果失败, 就会不断的向右兄弟节点迭代.
   因此, 在错误的状态下, 如果想找v中的内容, 那么情况是:
        1)找到parent, 2)通过parent找到u, 3)在u中查找失败, 4)通过u找到v, 5)查找成功.
   于是, 在DM的原子性保护下, 结合B+树本身的算法过程, 能够证明B+树是完全能够应对数据库崩坏的.
*/
package protocols

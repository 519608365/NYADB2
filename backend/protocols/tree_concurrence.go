/*
   tree_concurrence.go 描述B+树上的并发控制协议, 并证明该协议是无死锁的.

   我们用u来表示B+树上的某个节点, 用s(u)来表示它右边的那个兄弟节点.
   每个节点都有一个读写锁, 并规定, 在对u做任意读取之前, 都必须要调用u.RLock(),
   在对u做任意修改之前, 都必须要调用u.WLock(). 且u.Leaf()能够返回该节点是否为叶子节点.

   另外, 我们规定, 任意的事务Ti, 在某一时刻, 最多只能取得一个节点的锁.
   也就是说, 现在Ti取得u的锁, 如果它想访问下一个节点v, 那么它必须先释放掉u的锁.
   该协议能够保证在并发访问的情况下, 不会出现死锁.

   (下面的过程叙述需要你熟知B+树的算法, 请自行查阅资料.)

   下面先描述I(k, v)操作的过程, 假设初始u为B+树根节点:
   1)u.RLock();
   2)如果u.Leaf() == false, 则在u中查找下一个需要迭代的子节点v;
   2.1)如果查找失败(失败原因见后文), u.RUnlock(), u:=s(u), 重复2.
   2.2)如果查找成功, u.RUnlock(), 则另u:=v, 重复1.
   3)如果u.Leaf() == true, u.RUnlock(), u.WLock(), 并尝试向u中插入(k, v);
   3.1)如果插入失败(失败原因见后文), u.WUnlock(), 则另u:=s(u), 重复3.
   3.2)如果插入成功, 检测u是否需要分裂;
   3.2.1)如果不需要, u.WUnlock(), 插入成功, 直接返回.
   3.2.2)如果需要, 则依照B+树算法, 创建新节点v, 另s(u):=v, u.WUnlock().
   4)递归的向父亲节点插入新增加的节点(如果需要的话), 直至根节点.

   现在说明插入失败, 和查找失败的原因. 假设T1准备向B+树中插入(10, 10), 并有如下的执行序列:
   1) T1当前在u节点, 并查询到它下一个需要访问的节点是v; // 注意此时T1并没有v的锁
   2) T2向v中插入了(8, 10), 使得v从原来的[(1, 1), (2, 2), (10, 10)],
      变成了[(1, 1), (2, 2), (8, 8), (10, 10)],
      并被分裂成为v[(1, 1), (2, 2)], s(v)[(8, 8), (10, 10)]
   3) T2执行v.WUnlock()
   4) T1取得v, 并执行v.RLock(), 接着进行查询

   可见, 在T1对v进行查询时, 便会发生查询失败, 原因也很显而易见:
       在T1得知要查询v, 到T1对v进行查询期间, 有其他事务对v操作并让其产生了分裂.
   v被分裂过后, 它原本的一部分数据就会被移动到s(v)中, 于是则需要在查询失败后, 继续对s(v)进行查询.
   插入操作也是同理.
   对于S(key)的操作就不用赘述了, 就是I(key, value)中的1), 2), 3)步, 只不过把对应的插入操作改为查询操作.

*/
package protocols
